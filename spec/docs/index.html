<!DOCTYPE html><html lang="en" dir="ltr"><head>
<meta charset="utf-8">
<meta name="generator" content="ReSpec 35.2.2">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<style>
dfn{cursor:pointer}
.dfn-panel{position:absolute;z-index:35;min-width:300px;max-width:500px;padding:.5em .75em;margin-top:.6em;font-family:"Helvetica Neue",sans-serif;font-size:small;background:#fff;background:var(--indextable-hover-bg,#fff);color:#000;color:var(--text,#000);box-shadow:0 1em 3em -.4em rgba(0,0,0,.3),0 0 1px 1px rgba(0,0,0,.05);box-shadow:0 1em 3em -.4em var(--tocsidebar-shadow,rgba(0,0,0,.3)),0 0 1px 1px var(--tocsidebar-shadow,rgba(0,0,0,.05));border-radius:2px}
.dfn-panel:not(.docked)>.caret{position:absolute;top:-9px}
.dfn-panel:not(.docked)>.caret::after,.dfn-panel:not(.docked)>.caret::before{content:"";position:absolute;border:10px solid transparent;border-top:0;border-bottom:10px solid #fff;border-bottom-color:var(--indextable-hover-bg,#fff);top:0}
.dfn-panel:not(.docked)>.caret::before{border-bottom:9px solid #a2a9b1;border-bottom-color:var(--indextable-hover-bg,#a2a9b1)}
.dfn-panel *{margin:0}
.dfn-panel b{display:block;color:#000;color:var(--text,#000);margin-top:.25em}
.dfn-panel ul a[href]{color:#333;color:var(--text,#333)}
.dfn-panel>div{display:flex}
.dfn-panel a.self-link{font-weight:700;margin-right:auto}
.dfn-panel .marker{padding:.1em;margin-left:.5em;border-radius:.2em;text-align:center;white-space:nowrap;font-size:90%;color:#040b1c}
.dfn-panel .marker.dfn-exported{background:#d1edfd;box-shadow:0 0 0 .125em #1ca5f940}
.dfn-panel .marker.idl-block{background:#8ccbf2;box-shadow:0 0 0 .125em #0670b161}
.dfn-panel a:not(:hover){text-decoration:none!important;border-bottom:none!important}
.dfn-panel a[href]:hover{border-bottom-width:1px}
.dfn-panel ul{padding:0}
.dfn-panel li{margin-left:1em}
.dfn-panel.docked{position:fixed;left:.5em;top:unset;bottom:2em;margin:0 auto;max-width:calc(100vw - .75em * 2 - .5em - .2em * 2);max-height:30vh;overflow:auto}
</style>
    
<title>RML-CC: Collections and Containers in RML</title>
    
    
<link rel="stylesheet" type="text/css" href="./resources/css/extras.css">
    
    
<style type="text/css">

        /* Adapted from R2RML */
        pre {
            word-wrap:normal
        }
        pre.ex-input,
        pre.ex-mapping,
        pre.ex-output,
        pre.ex-target,
        pre.ex-access {
            margin-top: 1.5em;
            padding: 1em;
            font-size: 75%;
        }
        pre.ex-input:before,
        pre.ex-mapping:before,
        pre.ex-output:before,
        pre.ex-target:before,
        pre.ex-access:before {
            background: white;
            display: block;
            font-family: sans-serif;
            font-size: 90%;
            margin: -1.5em 0 0.5em 0;
            padding: 0.4em 0.4em;
            width: 18em;
        }
        /* Input data example */
        pre.ex-input {
            background: #cee;
        }
        pre.ex-input,
        pre.ex-input:before {
            border: 1px solid #acc;
        }
        pre.ex-input:before {
            content: "Example input data";
        }
        /* RML mapping example */
        pre.ex-mapping {
            background: #eeb;
        }
        pre.ex-mapping,
        pre.ex-mapping:before {
            border: 1px solid #cc9;
        }
        pre.ex-mapping:before {
            content: "Example mapping";
        }
        /* Output RDF example */
        pre.ex-output {
            background: #cfc;
        }
        pre.ex-output,
        pre.ex-output:before {
            border: 1px solid #aca;
        }
        pre.ex-output:before {
            content: "Example RDF";
        }
    
</style>
    
    
    

<style id="respec-mainstyle">
@keyframes pop{
0%{transform:scale(1,1)}
25%{transform:scale(1.25,1.25);opacity:.75}
100%{transform:scale(1,1)}
}
a.internalDFN{color:inherit;border-bottom:1px solid #99c;text-decoration:none}
a.externalDFN{color:inherit;border-bottom:1px dotted #ccc;text-decoration:none}
a.bibref{text-decoration:none}
.respec-offending-element:target{animation:pop .25s ease-in-out 0s 1}
.respec-offending-element,a[href].respec-offending-element{text-decoration:red wavy underline}
@supports not (text-decoration:red wavy underline){
.respec-offending-element:not(pre){display:inline-block}
.respec-offending-element{background:url(data:image/gif;base64,R0lGODdhBAADAPEAANv///8AAP///wAAACwAAAAABAADAEACBZQjmIAFADs=) bottom repeat-x}
}
#references :target{background:#eaf3ff;animation:pop .4s ease-in-out 0s 1}
cite .bibref{font-style:normal}
a[href].orcid{padding-left:4px;padding-right:4px}
a[href].orcid>svg{margin-bottom:-2px}
ol.tof,ul.tof{list-style:none outside none}
.caption{margin-top:.5em;font-style:italic}
#issue-summary>ul{column-count:2}
#issue-summary li{list-style:none;display:inline-block}
details.respec-tests-details{margin-left:1em;display:inline-block;vertical-align:top}
details.respec-tests-details>*{padding-right:2em}
details.respec-tests-details[open]{z-index:999999;position:absolute;border:thin solid #cad3e2;border-radius:.3em;background-color:#fff;padding-bottom:.5em}
details.respec-tests-details[open]>summary{border-bottom:thin solid #cad3e2;padding-left:1em;margin-bottom:1em;line-height:2em}
details.respec-tests-details>ul{width:100%;margin-top:-.3em}
details.respec-tests-details>li{padding-left:1em}
.self-link:hover{opacity:1;text-decoration:none;background-color:transparent}
aside.example .marker>a.self-link{color:inherit}
.header-wrapper{display:flex;align-items:baseline}
:is(h2,h3,h4,h5,h6):not(#toc>h2,#abstract>h2,#sotd>h2,.head>h2){position:relative;left:-.5em}
:is(h2,h3,h4,h5,h6):not(#toch2)+a.self-link{color:inherit;order:-1;position:relative;left:-1.1em;font-size:1rem;opacity:.5}
:is(h2,h3,h4,h5,h6)+a.self-link::before{content:"§";text-decoration:none;color:var(--heading-text)}
:is(h2,h3)+a.self-link{top:-.2em}
:is(h4,h5,h6)+a.self-link::before{color:#000}
@media (max-width:767px){
dd{margin-left:0}
}
@media print{
.removeOnSave{display:none}
}
</style>
<meta name="color-scheme" content="light">
<meta name="description" content="This document describes the [RML] vocabulary and approach to generating RDF containers and collections [RDF11-Concepts].">
<style>
.hljs{--base:#fafafa;--mono-1:#383a42;--mono-2:#686b77;--mono-3:#717277;--hue-1:#0b76c5;--hue-2:#336ae3;--hue-3:#a626a4;--hue-4:#42803c;--hue-5:#ca4706;--hue-5-2:#c91243;--hue-6:#986801;--hue-6-2:#9a6a01}
@media (prefers-color-scheme:dark){
.hljs{--base:#282c34;--mono-1:#abb2bf;--mono-2:#818896;--mono-3:#5c6370;--hue-1:#56b6c2;--hue-2:#61aeee;--hue-3:#c678dd;--hue-4:#98c379;--hue-5:#e06c75;--hue-5-2:#be5046;--hue-6:#d19a66;--hue-6-2:#e6c07b}
}
.hljs{display:block;overflow-x:auto;padding:.5em;color:#383a42;color:var(--mono-1,#383a42);background:#fafafa;background:var(--base,#fafafa)}
.hljs-comment,.hljs-quote{color:#717277;color:var(--mono-3,#717277);font-style:italic}
.hljs-doctag,.hljs-formula,.hljs-keyword{color:#a626a4;color:var(--hue-3,#a626a4)}
.hljs-deletion,.hljs-name,.hljs-section,.hljs-selector-tag,.hljs-subst{color:#ca4706;color:var(--hue-5,#ca4706);font-weight:700}
.hljs-literal{color:#0b76c5;color:var(--hue-1,#0b76c5)}
.hljs-addition,.hljs-attribute,.hljs-meta-string,.hljs-regexp,.hljs-string{color:#42803c;color:var(--hue-4,#42803c)}
.hljs-built_in,.hljs-class .hljs-title{color:#9a6a01;color:var(--hue-6-2,#9a6a01)}
.hljs-attr,.hljs-number,.hljs-selector-attr,.hljs-selector-class,.hljs-selector-pseudo,.hljs-template-variable,.hljs-type,.hljs-variable{color:#986801;color:var(--hue-6,#986801)}
.hljs-bullet,.hljs-link,.hljs-meta,.hljs-selector-id,.hljs-symbol,.hljs-title{color:#336ae3;color:var(--hue-2,#336ae3)}
.hljs-emphasis{font-style:italic}
.hljs-strong{font-weight:700}
.hljs-link{text-decoration:underline}
</style>
<style>
var{position:relative;cursor:pointer}
var[data-type]::after,var[data-type]::before{position:absolute;left:50%;top:-6px;opacity:0;transition:opacity .4s;pointer-events:none}
var[data-type]::before{content:"";transform:translateX(-50%);border-width:4px 6px 0 6px;border-style:solid;border-color:transparent;border-top-color:#222}
var[data-type]::after{content:attr(data-type);transform:translateX(-50%) translateY(-100%);background:#222;text-align:center;font-family:"Dank Mono","Fira Code",monospace;font-style:normal;padding:6px;border-radius:3px;color:#daca88;text-indent:0;font-weight:400}
var[data-type]:hover::after,var[data-type]:hover::before{opacity:1}
</style>
<script id="initialUserConfig" type="application/json">{
  "localBiblio": {
    "RDF11-Concepts": {
      "title": "RDF 1.1 Concepts and Abstract Syntax",
      "href": "https://www.w3.org/TR/rdf11-concepts/",
      "status": "W3C Recommendation",
      "publisher": "W3C",
      "date": "25 February 2014",
      "id": "rdf11-concepts"
    },
    "Turtle": {
      "title": "RDF 1.1 Turtle",
      "href": "https://www.w3.org/TR/turtle/",
      "status": "W3C Recommendation",
      "publisher": "W3C",
      "date": "25 February 2014",
      "id": "turtle"
    },
    "RML": {
      "title": "RDF Mapping Language",
      "href": "https://rml.io/specs/rml/",
      "status": "Unofficial draft",
      "publisher": "https://rml.io",
      "date": "06 October 2020",
      "id": "rml"
    },
    "R2RML": {
      "title": "R2RML: RDB to RDF Mapping Language",
      "href": "https://www.w3.org/TR/r2rml/",
      "status": "W3C Recommendation",
      "publisher": "W3C",
      "date": "27 September 2012",
      "id": "r2rml"
    }
  },
  "doRdfa": "true",
  "processVersion": 2021,
  "specStatus": "CG-DRAFT",
  "shortName": "rml-cc",
  "copyrightStart": "2022",
  "edDraftURI": "https://w3id.org/rml/cc/spec",
  "authors": [
    {
      "name": "Christophe Debruyne",
      "company": "Montefiore Institute, University of Liège",
      "url": "http://www.christophedebruyne.be/",
      "orcid": "https://orcid.org/0000-0003-4734-3847",
      "companyURL": "https://www.montefiore.uliege.be/"
    },
    {
      "name": "Franck Michel",
      "company": "Université Côte d'Azur, CNRS, Inria",
      "url": "https://w3id.org/people/franckmichel",
      "orcid": "https://orcid.org/0000-0001-9064-0463",
      "companyURL": "https://www.cnrs.fr/"
    }
  ],
  "editors": [
    {
      "name": "Christophe Debruyne",
      "company": "Montefiore Institute, University of Liège",
      "url": "http://www.christophedebruyne.be/",
      "orcid": "https://orcid.org/0000-0003-4734-3847",
      "companyURL": "https://www.montefiore.uliege.be/"
    },
    {
      "name": "Franck Michel",
      "company": "Université Côte d'Azur, CNRS, Inria",
      "url": "https://w3id.org/people/franckmichel",
      "orcid": "https://orcid.org/0000-0001-9064-0463",
      "companyURL": "https://www.cnrs.fr/"
    }
  ],
  "group": "kg-construct",
  "latestVersion": null,
  "issueBase": "https://github.com/kg-construct/rml-cc/issues",
  "noRecTrack": "true",
  "otherLinks": [
    {
      "key": "Website",
      "data": [
        {
          "value": "https://github.com/kg-construct/rml-cc/",
          "href": "https://github.com/kg-construct/rml-cc/"
        }
      ]
    }
  ],
  "publishISODate": "2025-02-25T00:00:00.000Z",
  "generatedSubtitle": "Draft Community Group Report 25 February 2025"
}</script>
<link rel="stylesheet" href="https://www.w3.org/StyleSheets/TR/2021/cg-draft"></head>
<body data-new-gr-c-s-check-loaded="14.1223.0" data-gr-ext-installed="" class="h-entry"><div class="head">
    
    <h1 id="title" class="title">RML-CC: Collections and Containers in RML</h1> 
    <p id="w3c-state">
      <a href="https://www.w3.org/standards/types#reports">Draft Community Group Report</a>
      <time class="dt-published" datetime="2025-02-25">25 February 2025</time>
    </p>
    <dl>
      
      <dt>Latest published version:</dt><dd>
              none
            </dd>
      <dt>Latest editor's draft:</dt><dd><a href="https://w3id.org/rml/cc/spec">https://w3id.org/rml/cc/spec</a></dd>
      
      
      
      
      <dt>Editors:</dt><dd class="editor p-author h-card vcard">
    <a class="u-url url p-name fn" href="http://www.christophedebruyne.be/">Christophe Debruyne</a><a class="p-name orcid" href="https://orcid.org/0000-0003-4734-3847"><svg width="16" height="16" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 256 256">
    <style>

      .st1 {
        fill: #fff;
      }
    
</style>
    <path d="M256 128c0 70.7-57.3 128-128 128S0 198.7 0 128 57.3 0 128 0s128 57.3 128 128z" fill="#a6ce39"></path>
    <path class="st1" d="M86.3 186.2H70.9V79.1h15.4v107.1zM108.9 79.1h41.6c39.6 0 57 28.3 57 53.6 0 27.5-21.5 53.6-56.8 53.6h-41.8V79.1zm15.4 93.3h24.5c34.9 0 42.9-26.5 42.9-39.7C191.7 111.2 178 93 148 93h-23.7v79.4zM88.7 56.8c0 5.5-4.5 10.1-10.1 10.1s-10.1-4.6-10.1-10.1c0-5.6 4.5-10.1 10.1-10.1s10.1 4.6 10.1 10.1z"></path>
  </svg></a> (<a class="p-org org h-org" href="https://www.montefiore.uliege.be/">Montefiore Institute, University of Liège</a>)
  </dd><dd class="editor p-author h-card vcard">
    <a class="u-url url p-name fn" href="https://w3id.org/people/franckmichel">Franck Michel</a><a class="p-name orcid" href="https://orcid.org/0000-0001-9064-0463"><svg width="16" height="16" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 256 256">
    <style>

      .st1 {
        fill: #fff;
      }
    
</style>
    <path d="M256 128c0 70.7-57.3 128-128 128S0 198.7 0 128 57.3 0 128 0s128 57.3 128 128z" fill="#a6ce39"></path>
    <path class="st1" d="M86.3 186.2H70.9V79.1h15.4v107.1zM108.9 79.1h41.6c39.6 0 57 28.3 57 53.6 0 27.5-21.5 53.6-56.8 53.6h-41.8V79.1zm15.4 93.3h24.5c34.9 0 42.9-26.5 42.9-39.7C191.7 111.2 178 93 148 93h-23.7v79.4zM88.7 56.8c0 5.5-4.5 10.1-10.1 10.1s-10.1-4.6-10.1-10.1c0-5.6 4.5-10.1 10.1-10.1s10.1 4.6 10.1 10.1z"></path>
  </svg></a> (<a class="p-org org h-org" href="https://www.cnrs.fr/">Université Côte d'Azur, CNRS, Inria</a>)
  </dd>
      
      <dt>Authors:</dt><dd class="editor p-author h-card vcard">
    <a class="u-url url p-name fn" href="http://www.christophedebruyne.be/">Christophe Debruyne</a><a class="p-name orcid" href="https://orcid.org/0000-0003-4734-3847"><svg width="16" height="16" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 256 256">
    <style>

      .st1 {
        fill: #fff;
      }
    
</style>
    <path d="M256 128c0 70.7-57.3 128-128 128S0 198.7 0 128 57.3 0 128 0s128 57.3 128 128z" fill="#a6ce39"></path>
    <path class="st1" d="M86.3 186.2H70.9V79.1h15.4v107.1zM108.9 79.1h41.6c39.6 0 57 28.3 57 53.6 0 27.5-21.5 53.6-56.8 53.6h-41.8V79.1zm15.4 93.3h24.5c34.9 0 42.9-26.5 42.9-39.7C191.7 111.2 178 93 148 93h-23.7v79.4zM88.7 56.8c0 5.5-4.5 10.1-10.1 10.1s-10.1-4.6-10.1-10.1c0-5.6 4.5-10.1 10.1-10.1s10.1 4.6 10.1 10.1z"></path>
  </svg></a> (<a class="p-org org h-org" href="https://www.montefiore.uliege.be/">Montefiore Institute, University of Liège</a>)
  </dd><dd class="editor p-author h-card vcard">
    <a class="u-url url p-name fn" href="https://w3id.org/people/franckmichel">Franck Michel</a><a class="p-name orcid" href="https://orcid.org/0000-0001-9064-0463"><svg width="16" height="16" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 256 256">
    <style>

      .st1 {
        fill: #fff;
      }
    
</style>
    <path d="M256 128c0 70.7-57.3 128-128 128S0 198.7 0 128 57.3 0 128 0s128 57.3 128 128z" fill="#a6ce39"></path>
    <path class="st1" d="M86.3 186.2H70.9V79.1h15.4v107.1zM108.9 79.1h41.6c39.6 0 57 28.3 57 53.6 0 27.5-21.5 53.6-56.8 53.6h-41.8V79.1zm15.4 93.3h24.5c34.9 0 42.9-26.5 42.9-39.7C191.7 111.2 178 93 148 93h-23.7v79.4zM88.7 56.8c0 5.5-4.5 10.1-10.1 10.1s-10.1-4.6-10.1-10.1c0-5.6 4.5-10.1 10.1-10.1s10.1 4.6 10.1 10.1z"></path>
  </svg></a> (<a class="p-org org h-org" href="https://www.cnrs.fr/">Université Côte d'Azur, CNRS, Inria</a>)
  </dd>
      
      <dt>Website</dt><dd>
    <a href="https://github.com/kg-construct/rml-cc/">https://github.com/kg-construct/rml-cc/</a>
  </dd>
    </dl>
    
    <p class="copyright">
          <a href="https://www.w3.org/policies/#copyright">Copyright</a>
          ©
          2022-2025
          
          the Contributors to the RML-CC: Collections and Containers in RML
          Specification, published by the
          <a href="https://www.w3.org/groups/cg/kg-construct">Knowledge Graph Construction Community Group</a> under the
          <a href="https://www.w3.org/community/about/agreements/cla/">W3C Community Contributor License Agreement (CLA)</a>. A human-readable
                <a href="https://www.w3.org/community/about/agreements/cla-deed/">summary</a>
                is available.
              
        </p>
    <hr title="Separator for header">
  </div>
<section id="abstract" class="introductory"><h2 id="abstract">Abstract</h2><p>This document describes the [<cite><a class="bibref" data-link-type="biblio" href="#bib-rml" title="RDF Mapping Language">RML</a></cite>] vocabulary and approach to generating RDF containers and collections [<cite><a class="bibref" data-link-type="biblio" href="#bib-rdf11-concepts" title="RDF 1.1 Concepts and Abstract Syntax">RDF11-Concepts</a></cite>].</p>
</section>

<section id="sotd" class="introductory"><h2>Status of This Document</h2><p>
      This specification was published by the
      <a href="https://www.w3.org/groups/cg/kg-construct">Knowledge Graph Construction Community Group</a>. It is not a W3C Standard nor is it
      on the W3C Standards Track.
      
            Please note that under the
            <a href="https://www.w3.org/community/about/agreements/cla/">W3C Community Contributor License Agreement (CLA)</a>
            there is a limited opt-out and other conditions apply.
          
      Learn more about
      <a href="https://www.w3.org/community/">W3C Community and Business Groups</a>.
    </p></section><nav id="toc"><h2 class="introductory" id="table-of-contents">Table of Contents</h2><ol class="toc"><li class="tocline"><a class="tocxref" href="#abstract">Abstract</a></li><li class="tocline"><a class="tocxref" href="#sotd">Status of This Document</a></li><li class="tocline"><a class="tocxref" href="#conformance"><bdi class="secno">1. </bdi>Conformance</a></li><li class="tocline"><a class="tocxref" href="#overview"><bdi class="secno">2. </bdi>Overview</a><ol class="toc"><li class="tocline"><a class="tocxref" href="#conformance"><bdi class="secno">2.1 </bdi>Conformance</a></li><li class="tocline"><a class="tocxref" href="#conventions"><bdi class="secno">2.2 </bdi>Document conventions</a></li></ol></li><li class="tocline"><a class="tocxref" href="#definitions"><bdi class="secno">3. </bdi>Definitions</a><ol class="toc"><li class="tocline"><a class="tocxref" href="#iterations"><bdi class="secno">3.1 </bdi>Iterations</a></li><li class="tocline"><a class="tocxref" href="#multivaluedtermmap"><bdi class="secno">3.2 </bdi>Multi-valued term map</a></li><li class="tocline"><a class="tocxref" href="#named"><bdi class="secno">3.3 </bdi>Named collection or container</a></li><li class="tocline"><a class="tocxref" href="#wellformedness"><bdi class="secno">3.4 </bdi>Well-formed vs. ill-formed collections and containers</a></li></ol></li><li class="tocline"><a class="tocxref" href="#overview"><bdi class="secno">4. </bdi>Presentation and Example (Informative)</a><ol class="toc"><li class="tocline"><a class="tocxref" href="#runningexample"><bdi class="secno">4.1 </bdi>Running example</a></li><li class="tocline"><a class="tocxref" href="#simpleexample"><bdi class="secno">4.2 </bdi>A simple example</a></li><li class="tocline"><a class="tocxref" href="#collections-and-containers-identified-with-an-iri-or-blank-node-id"><bdi class="secno">4.3 </bdi>Collections and containers identified with an IRI or blank node ID</a></li></ol></li><li class="tocline"><a class="tocxref" href="#vocabulary"><bdi class="secno">5. </bdi>Vocabulary definition</a><ol class="toc"><li class="tocline"><a class="tocxref" href="#classes"><bdi class="secno">5.1 </bdi>Classes</a><ol class="toc"><li class="tocline"><a class="tocxref" href="#gathermapidentification"><bdi class="secno">5.1.1 </bdi><code>rml:GatherMap</code></a></li><li class="tocline"><a class="tocxref" href="#strategyclass"><bdi class="secno">5.1.2 </bdi><code>rml:Strategy</code></a></li></ol></li><li class="tocline"><a class="tocxref" href="#properties"><bdi class="secno">5.2 </bdi>Properties</a><ol class="toc"><li class="tocline"><a class="tocxref" href="#rml-gather"><bdi class="secno">5.2.1 </bdi><code>rml:gather</code></a></li><li class="tocline"><a class="tocxref" href="#rml-strategy-0"><bdi class="secno">5.2.2 </bdi><code>rml:strategy</code></a></li><li class="tocline"><a class="tocxref" href="#rml-gatheras"><bdi class="secno">5.2.3 </bdi><code>rml:gatherAs</code></a></li><li class="tocline"><a class="tocxref" href="#rml-allowemptylistandcontainer"><bdi class="secno">5.2.4 </bdi><code>rml:allowEmptyListAndContainer</code></a></li></ol></li><li class="tocline"><a class="tocxref" href="#constants"><bdi class="secno">5.3 </bdi>Constants</a><ol class="toc"><li class="tocline"><a class="tocxref" href="#rml-append"><bdi class="secno">5.3.1 </bdi><code>rml:append</code></a></li><li class="tocline"><a class="tocxref" href="#rml-cartesianproduct"><bdi class="secno">5.3.2 </bdi><code>rml:cartesianProduct</code></a></li></ol></li></ol></li><li class="tocline"><a class="tocxref" href="#considerations"><bdi class="secno">6. </bdi>Considerations</a><ol class="toc"><li class="tocline"><a class="tocxref" href="#using-a-rml-gathermap-in-various-types-of-term-map"><bdi class="secno">6.1 </bdi>Using a <code>rml:GatherMap</code> in various types of term map</a></li><li class="tocline"><a class="tocxref" href="#named-collection-or-container-assigning-an-iri-or-blank-node-identifier-to-a-collection-and-container"><bdi class="secno">6.2 </bdi>Named collection or container: assigning an IRI or blank node identifier to a collection and container</a></li><li class="tocline"><a class="tocxref" href="#generating-well-formed-named-collections-or-containers"><bdi class="secno">6.3 </bdi>Generating well-formed named collections or containers</a><ol class="toc"><li class="tocline"><a class="tocxref" href="#named-multi-iterations"><bdi class="secno">6.3.1 </bdi>Named collections or containers generated across multiple iterations</a></li><li class="tocline"><a class="tocxref" href="#named-multivalued"><bdi class="secno">6.3.2 </bdi>Named collections or containers generated by a multi-valued gather map</a></li><li class="tocline"><a class="tocxref" href="#named-collections-or-containers-generated-across-multiple-iterations-and-with-a-multi-valued-term-map"><bdi class="secno">6.3.3 </bdi>Named collections or containers generated across multiple iterations and with a multi-valued term map</a></li></ol></li></ol></li><li class="tocline"><a class="tocxref" href="#examples"><bdi class="secno">7. </bdi>Examples (Informative)</a><ol class="toc"><li class="tocline"><a class="tocxref" href="#dealing-with-empty-collections-and-containers"><bdi class="secno">7.1 </bdi>Dealing with empty collections and containers</a></li><li class="tocline"><a class="tocxref" href="#relationalexample"><bdi class="secno">7.2 </bdi>Relational data example</a></li><li class="tocline"><a class="tocxref" href="#using-referencing-object-map"><bdi class="secno">7.3 </bdi>Using referencing object map</a></li><li class="tocline"><a class="tocxref" href="#gatherinsubject"><bdi class="secno">7.4 </bdi>Using a gather map in a subject map</a></li></ol></li><li class="tocline"><a class="tocxref" href="#references"><bdi class="secno">A. </bdi>References</a><ol class="toc"><li class="tocline"><a class="tocxref" href="#normative-references"><bdi class="secno">A.1 </bdi>Normative references</a></li><li class="tocline"><a class="tocxref" href="#informative-references"><bdi class="secno">A.2 </bdi>Informative references</a></li></ol></li></ol></nav>
<section id="conformance"><div class="header-wrapper"><h2 id="x1-conformance"><bdi class="secno">1. </bdi>Conformance</h2><a class="self-link" href="#conformance" aria-label="Permalink for Section 1."></a></div><p>As well as sections marked as non-normative, all authoring guidelines, diagrams, examples, and notes in this specification are non-normative. Everything else in this specification is normative.</p><p>
        The key words <em class="rfc2119">MAY</em>, <em class="rfc2119">MUST</em>, and <em class="rfc2119">SHOULD</em> in this document
        are to be interpreted as described in
        <a href="https://datatracker.ietf.org/doc/html/bcp14">BCP 14</a>
        [<cite><a class="bibref" data-link-type="biblio" href="#bib-rfc2119" title="Key words for use in RFCs to Indicate Requirement Levels">RFC2119</a></cite>] [<cite><a class="bibref" data-link-type="biblio" href="#bib-rfc8174" title="Ambiguity of Uppercase vs Lowercase in RFC 2119 Key Words">RFC8174</a></cite>]
        when, and only when, they appear in all capitals, as shown here.
      </p></section>

<section id="overview-0"><div class="header-wrapper"><h2 id="overview"><bdi class="secno">2. </bdi>Overview</h2><a class="self-link" href="#overview" aria-label="Permalink for Section 2."></a></div><p><em>This section is non-normative.</em></p>
<p>The RDF Mapping Language (RML) [<cite><a class="bibref" data-link-type="biblio" href="#bib-rml" title="RDF Mapping Language">RML</a></cite>] is a language for expressing mappings between heterogeneous data and RDF. In RML, rules can be expressed to iterate over a data source and refer to specific data within an iteration. Using these iterators and references, RML rules define how to express data in the data source in RDF. RML is based on and extends R2RML [<cite><a class="bibref" data-link-type="biblio" href="#bib-r2rml" title="R2RML: RDB to RDF Mapping Language">R2RML</a></cite>]. R2RML is defined to express customized mappings only from relational databases to RDF datasets.</p>
<p>This document describes RML-CC:
an extension of RML that enables the generation of RDF collections and containers with RML.</p>
<section id="conformance-0"><div class="header-wrapper"><h3 id="conformance"><bdi class="secno">2.1 </bdi>Conformance</h3><a class="self-link" href="#conformance" aria-label="Permalink for Section 2.1"></a></div><p>As well as sections marked as non-normative, all authoring guidelines, diagrams, examples, and notes in this specification are non-normative. Everything else in this specification is normative.</p>
<p>The key words <em class="rfc2119">MUST</em> and <em class="rfc2119">SHOULD</em> in this document are to be interpreted as 
described in <a href="https://www.rfc-editor.org/info/bcp14">BCP 14</a> [<cite><a class="bibref" data-link-type="biblio" href="#bib-rfc2119" title="Key words for use in RFCs to Indicate Requirement Levels">RFC2119</a></cite>] [<cite><a class="bibref" data-link-type="biblio" href="#bib-rfc8174" title="Ambiguity of Uppercase vs Lowercase in RFC 2119 Key Words">RFC8174</a></cite>] when, 
and only when, they appear in all capitals, as shown here.</p>
</section><section id="document-conventions"><div class="header-wrapper"><h3 id="conventions"><bdi class="secno">2.2 </bdi>Document conventions</h3><a class="self-link" href="#conventions" aria-label="Permalink for Section 2.2"></a></div><p>We assume readers have basic familiarity with RDF and RML.</p>
<p>In this document, examples assume <code>http://example.org/</code> as the base IRI provided to the RML engine and
the following namespace prefix bindings unless otherwise stated:</p>
<table>
<thead>
<tr>
<th>Prefix</th>
<th>Namespace</th>
</tr>
</thead>
<tbody><tr>
<td><code>rml:</code></td>
<td><a href="http://w3id.org/rml/">http://w3id.org/rml/</a></td>
</tr>
<tr>
<td><code>xsd:</code></td>
<td><a href="http://www.w3.org/2001/XMLSchema#">http://www.w3.org/2001/XMLSchema#</a></td>
</tr>
<tr>
<td><code>ex:</code></td>
<td><a href="http://example.org/">http://example.org/</a></td>
</tr>
<tr>
<td><code>:</code></td>
<td><a href="http://example.org/">http://example.org/</a></td>
</tr>
</tbody></table>
<p>The examples are contained in color-coded boxes. We use the Turtle syntax [<cite><a class="bibref" data-link-type="biblio" href="#bib-turtle" title="RDF 1.1 Turtle">Turtle</a></cite>] to write RDF.</p>
<pre class="ex-input" aria-busy="false"><code class="hljs"># This box contains an example input</code></pre>

<pre class="ex-mapping" aria-busy="false"><code class="hljs"># This box contains an example mapping</code></pre>

<pre class="ex-output" aria-busy="false"><code class="hljs"># This box contains the example output</code></pre></section></section>

<section id="definitions-0"><div class="header-wrapper"><h2 id="definitions"><bdi class="secno">3. </bdi>Definitions</h2><a class="self-link" href="#definitions" aria-label="Permalink for Section 3."></a></div><section id="iterations-0"><div class="header-wrapper"><h3 id="iterations"><bdi class="secno">3.1 </bdi>Iterations</h3><a class="self-link" href="#iterations" aria-label="Permalink for Section 3.1"></a></div><p>In the course of this document, term <strong>"iteration"</strong> is used to refer to the iterations that stem from the logical source when processing the input documents.
An iteration results from the input data (documents, records returned by a query to a database etc.) on which the logical source may apply an optional <code>rml:iterator</code>.</p>
<p>In the <a href="#runningexample">running example</a>, the data source consists of a single document, the iterator then extracts each of the three sub-documents within the array, thus the logical source yields three iterations.</p>
</section><section id="multi-valued-term-map"><div class="header-wrapper"><h3 id="multivaluedtermmap"><bdi class="secno">3.2 </bdi>Multi-valued term map</h3><a class="self-link" href="#multivaluedtermmap" aria-label="Permalink for Section 3.2"></a></div><p>A <strong>multi-valued term map</strong> is a term map that, during a single <a href="#iterations">iteration</a>, may yield multiple RDF terms or multiple collections or containers in the case of a gather map.</p>
</section><section id="named-collection-or-container"><div class="header-wrapper"><h3 id="named"><bdi class="secno">3.3 </bdi>Named collection or container</h3><a class="self-link" href="#named" aria-label="Permalink for Section 3.3"></a></div><p>A <strong>named collection or container</strong> is a collection or container whose head node is assigned either an IRI or a blank node identifier.</p>
</section><section id="well-formed-vs-ill-formed-collections-and-containers"><div class="header-wrapper"><h3 id="wellformedness"><bdi class="secno">3.4 </bdi>Well-formed vs. ill-formed collections and containers</h3><a class="self-link" href="#wellformedness" aria-label="Permalink for Section 3.4"></a></div><p>There is an important difference between valid RDF and well-formed containers and collections. The following RDF is valid, though the collection is ill-formed since the first cons-pair has two <code>rdf:first</code> and two <code>rdf:rest</code> properties:</p>
<pre class="ex-output" aria-busy="false"><code class="hljs">ex:illformedList 
  rdf:first 1 ; rdf:rest (2 3) ;
  rdf:first 4 ; rdf:rest (5 6) .</code></pre>

<p>Similarly, an ill-formed container would have multiple times the same <code>rdf:_n</code> property, e.g.:</p>
<pre class="ex-output" aria-busy="false"><code class="hljs">ex:illformedContainer rdf:_1 1 ; rdf:_2 2 ; rdf:_3 3 ; rdf:_1 4 .</code></pre>

<p>An RML collection and container validator (RMLCCV) is a system that checks for the well-formedness of collections and containers. The RMLCCV <em class="rfc2119">MUST</em> report on any ill-formed collections and containers that are raised in the RDF generation process. An RML processor may include an RMLCCV, but this is not required.</p>
</section></section>

<section id="presentation-and-example-informative"><div class="header-wrapper"><h2 id="overview"><bdi class="secno">4. </bdi>Presentation and Example (Informative)</h2><a class="self-link" href="#overview" aria-label="Permalink for Section 4."></a></div><p>This section gives a brief overview of the RML mapping language. 
It also provides simple examples of the generation of RDF collections and containers from JSON documents.</p>
<p>Herebelow we present the three main constructs for generating collections and containers. Other predicates, and their use in examples, will be explained further down this document.</p>
<p>An <a href="#rml-gathermap"><code>rml:GatherMap</code></a> is a term map that generates a collection (<code>rdf:List</code>) or container (<code>rdf:Bag</code>, <code>rdf:Seq</code>, <code>rdf:Alt</code>). 
A gather map has a list of term maps that inform the RML processor which RDF terms have to be generated as members of the list or container. 
The <a href="#rml-gather"><code>rml:gather</code></a> predicate is used to link an instance of <a href="#rml-gathermap"><code>rml:GatherMap</code></a> with a list of term maps. The generation of a collection or container depends on the <code>rml:gatherAs</code> predicate, which may take any of the following values: <code>rdf:List</code>, <code>rdf:Bag</code>, <code>rdf:Seq</code>,  and <code>rdf:Alt</code>.</p>
<p>The figure below illustrates the GatherMap and its relationships with other entities of the RML model.</p>
<figure id="fig-graphical-overview-of-rml-s-vocabulary-to-generate-rdf-collections-and-containers">
  <img src="./resources/images/overview.svg" alt="Graphical overview of RML's vocabulary to generate RDF collections and containers.">
  <figcaption><a class="self-link" href="#fig-graphical-overview-of-rml-s-vocabulary-to-generate-rdf-collections-and-containers">Figure <bdi class="figno">1</bdi></a> <span class="fig-title">Graphical overview of RML's vocabulary to generate RDF collections and containers.</span></figcaption>
</figure>


<section id="running-example"><div class="header-wrapper"><h3 id="runningexample"><bdi class="secno">4.1 </bdi>Running example</h3><a class="self-link" href="#runningexample" aria-label="Permalink for Section 4.1"></a></div><p>In this section, the data source consists of a JSON file, <code>data.json</code>, containing the following JSON array:</p>
<pre class="ex-input" aria-busy="false"><code class="hljs">[ 
  { "id": "a",  "values": [ "1" , "2" , "3" ] },
  { "id": "b",  "values": [ "4" , "5" , "6" ] },
  { "id": "c",  "values": [ "7" , "8" , "9" ] } 
]</code></pre>

<p>The associated RML mapping starts as follows:</p>
<pre class="ex-mapping" aria-busy="false"><code class="hljs">@prefix rml: &lt;http://w3id.org/rml/&gt;.
@prefix ex:  &lt;http://example.com/ns/&gt;.
@base        &lt;http://example.com/ns/&gt;.

&lt;#TM&gt; a rml:TriplesMap;
  rml:logicalSource [
    rml:referenceFormulation rml:JSONPath;
    rml:source [ 
        a rml:RelativePathSource;
        rml:root rml:MappingDirectory;
        rml:path "data.json"
    ] ;
    rml:iterator "$.*" ;
  ];

  rml:subjectMap [
    rml:template "{id}" ;
  ] ;
.</code></pre>

<p>Note that the <code>rml:iterator</code> in the logical source will yield three <a href="#iterations">iterations</a>, each one providing one of the three sub-documents of the JSON array:</p>
<pre class="ex-input" aria-busy="false"><code class="hljs">{ "id": "a",  "values": [ "1" , "2" , "3" ] }
{ "id": "b",  "values": [ "4" , "5" , "6" ] }
{ "id": "c",  "values": [ "7" , "8" , "9" ] }</code></pre>


</section><section id="a-simple-example"><div class="header-wrapper"><h3 id="simpleexample"><bdi class="secno">4.2 </bdi>A simple example</h3><a class="self-link" href="#simpleexample" aria-label="Permalink for Section 4.2"></a></div><p>Given the JSON document and the RML mapping completed with the following predicate object map:</p>
<pre class="ex-mapping" aria-busy="false"><code class="hljs">rml:predicateObjectMap [
  rml:predicate ex:with ;
  rml:objectMap [
      rml:gather ( [ rml:reference "values.*" ; ] ) ;
      rml:gatherAs rdf:List ;
  ] ;
] ;</code></pre>

<p>In this example, each <a href="#iterations">iteration</a> yields a new (unique) blank node that is the head of the collection being produced.
The following output will be produced:</p>
<pre class="ex-output" aria-busy="false"><code class="hljs">:a ex:with ("1" "2" "3") .
:b ex:with ("4" "5" "6") .
:c ex:with ("7" "8" "9") .</code></pre>


</section><section id="collections-and-containers-identified-with-an-iri-or-blank-node-id"><div class="header-wrapper"><h3 id="x4-3-collections-and-containers-identified-with-an-iri-or-blank-node-id"><bdi class="secno">4.3 </bdi>Collections and containers identified with an IRI or blank node ID</h3><a class="self-link" href="#collections-and-containers-identified-with-an-iri-or-blank-node-id" aria-label="Permalink for Section 4.3"></a></div>
<p>In the previous example, the gather map does not contain any <code>rml:template</code>, <code>rml:constant</code> or <code>rml:reference</code> property.
By contrast, the example below identifies the collection with a <code>rml:template</code> property. The IRI generated by the template will be assigned to the head node of the collection. We refer to this as a <strong><a href="#named">named collection</a></strong>.</p>
<p>The following mapping:</p>
<pre class="ex-mapping" aria-busy="false"><code class="hljs">rml:predicateObjectMap [
  rml:predicate ex:with ;
  rml:objectMap [
      rml:template "list{id}" ;
      rml:gather ( [ rml:reference "values.*" ; ] ) ;
      rml:gatherAs rdf:List ;
  ] ;
] ;</code></pre>

<p>will yield the following output:</p>
<pre class="ex-output" aria-busy="false"><code class="hljs">:a ex:with :lista . :lista rdf:first "1" ; rdf:rest ("2" "3") .
:b ex:with :listb . :listb rdf:first "4" ; rdf:rest ("5" "6") .
:c ex:with :listc . :listc rdf:first "7" ; rdf:rest ("8" "9") .</code></pre>

<p>This is similar to the previous example, yet in this case the head node of each produced collection is assigned an IRI <code>:lista</code>, <code>:listb</code> and <code>:listc</code>.</p>
</section></section>

<section id="vocabulary-definition"><div class="header-wrapper"><h2 id="vocabulary"><bdi class="secno">5. </bdi>Vocabulary definition</h2><a class="self-link" href="#vocabulary" aria-label="Permalink for Section 5."></a></div><p>This section introduces the classes, properties, and constants of the RML Containers and Collections specification.</p>
<section id="classes"><div class="header-wrapper"><h3 id="x5-1-classes"><bdi class="secno">5.1 </bdi>Classes</h3><a class="self-link" href="#classes" aria-label="Permalink for Section 5.1"></a></div>
<section id="rml-gathermap"><div class="header-wrapper"><h4 id="gathermapidentification"><bdi class="secno">5.1.1 </bdi><code>rml:GatherMap</code></h4><a class="self-link" href="#gathermapidentification" aria-label="Permalink for Section 5.1.1"></a></div><p>Gather maps are term maps that use <a href="#rml-gather"><code>rml:gather</code></a> and <a href="#rml-gatheras"><code>rml:gatherAs</code></a> to generate collections and containers from a list of term maps. </p>
<ul>
<li>A <code>rml:GatherMap</code> <em class="rfc2119">MUST</em> have exactly one <a href="#rml-gather"><code>rml:gather</code></a> property.</li>
<li>A <code>rml:GatherMap</code> <em class="rfc2119">MUST</em> have exactly one <a href="#rml-gatheras"><code>rml:gatherAs</code></a> property.</li>
<li>A <code>rml:GatherMap</code> <em class="rfc2119">MAY</em> have zero or exactly one <a href="#rml-strategy"><code>rml:strategy</code></a> property.</li>
</ul>
</section><section id="rml-strategy"><div class="header-wrapper"><h4 id="strategyclass"><bdi class="secno">5.1.2 </bdi><code>rml:Strategy</code></h4><a class="self-link" href="#strategyclass" aria-label="Permalink for Section 5.1.2"></a></div><p>A strategy is a plan or set of actions designed to achieve a specific goal or outcome. Instances of <code>rml:Strategy</code> represent ways to perform an action such as combining two collections and containers. See <a href="#constants"><strong>constants</strong></a> for examples. </p>
</section></section><section id="properties"><div class="header-wrapper"><h3 id="x5-2-properties"><bdi class="secno">5.2 </bdi>Properties</h3><a class="self-link" href="#properties" aria-label="Permalink for Section 5.2"></a></div>
<section id="rml-gather"><div class="header-wrapper"><h4 id="x5-2-1-rml-gather"><bdi class="secno">5.2.1 </bdi><code>rml:gather</code></h4><a class="self-link" href="#rml-gather" aria-label="Permalink for Section 5.2.1"></a></div>
<p>The <code>rml:gather</code> informs the RML processor where the terms of a collection or container come from. This property relates a gather map with a non-empty list of term maps. 
That list of term maps may contain other gather maps thus generating nested containers and/or collections.</p>
<ul>
<li>The domain of <code>rml:gather</code> is <a href="#rml-gathermap"><code>rml:GatherMap</code></a>.</li>
<li>The range of <code>rml:gather</code> is a non-empty list (rdf:List) of <code>rml:TermMap</code> instances. In particular, this list may include instances of <a href="#rml-gathermap"><code>rml:GatherMap</code></a> thus allowing for nested gather maps.</li>
</ul>
</section><section id="rml-strategy-0"><div class="header-wrapper"><h4 id="x5-2-2-rml-strategy"><bdi class="secno">5.2.2 </bdi><code>rml:strategy</code></h4><a class="self-link" href="#rml-strategy-0" aria-label="Permalink for Section 5.2.2"></a></div>
<p>Declaring an <code>rml:strategy</code> in a gather map informs the processor about how to create collections and containers when faced with <a href="#multivaluedtermmap"><strong>multi-valued term maps</strong></a>.
This specification defines <a href="#rml-append"><code>rml:append</code></a> and <a href="#rml-cartesianproduct"><code>rml:cartesianProduct</code></a> as instances of <code>rml:Strategy</code>. </p>
<p>In the <a href="#rml-append"><code>rml:append</code></a> strategy, the sets of RDF terms generated by each term map of the gather map are simply appended to the collection (respectively container) being constructed. Thus, only one collection (respectively container) is generated.</p>
<p>Conversely, in the <a href="#rml-cartesianproduct"><code>rml:cartesianProduct</code></a> strategy, the gather map generates collections (respectively containers) each containing one RDF term generated by each term map of the gather map. In other words, it carries out a cartesian product between the terms generated by each term map, thus constructing as many collections (respectively containers) as the product of the number of RDF terms from each term map. </p>
<p>A gather map does not need to specify a strategy, <strong>the default strategy is <code>rml:append</code></strong>.</p>
</section><section id="rml-gatheras"><div class="header-wrapper"><h4 id="x5-2-3-rml-gatheras"><bdi class="secno">5.2.3 </bdi><code>rml:gatherAs</code></h4><a class="self-link" href="#rml-gatheras" aria-label="Permalink for Section 5.2.3"></a></div>
<p>The property <code>rml:gatherAs</code> relates a gather map with the desired result type: a type of container or collections.</p>
<ul>
<li>The domain of <code>rml:gatherAs</code> is <a href="#rml-gathermap"><code>rml:GatherMap</code></a>.</li>
<li>The range of <code>rml:gatherAs</code> is one of the following: <code>rdf:Seq</code>, <code>rdf:Bag</code>, <code>rdf:Alt</code>, <code>rdf:List</code>.</li>
</ul>
</section><section id="rml-allowemptylistandcontainer"><div class="header-wrapper"><h4 id="x5-2-4-rml-allowemptylistandcontainer"><bdi class="secno">5.2.4 </bdi><code>rml:allowEmptyListAndContainer</code></h4><a class="self-link" href="#rml-allowemptylistandcontainer" aria-label="Permalink for Section 5.2.4"></a></div>
<p>This predicate is to be used alongside <a href="#rml-gather"><code>rml:gather</code></a> and <a href="#rml-gatheras"><code>rml:gatherAs</code></a>. It specifies the behavior of a gather map in case the <a href="#rml-gather"><code>rml:gather</code></a> does not yield any element.</p>
<p>The range of <code>rml:allowEmptyListAndContainer</code> is <code>xsd:boolean</code>.
When true, the gather map will generate <code>rdf:nil</code> for an RDF collection, or a resource with no members for an RDF container.
When false, the gather map will not generate a collection or container.</p>
<ul>
<li>The domain of <code>rml:allowEmptyListAndContainer</code> is <a href="#rml-gathermap"><code>rml:GatherMap</code></a>.</li>
<li>The range of <code>rml:allowEmptyListAndContainer</code> is <code>xsd:boolean</code>.</li>
</ul>
<p>Property <code>rml:allowEmptyListAndContainer</code> is optional, it takes the value <strong>false</strong> by default.</p>
</section></section><section id="constants-0"><div class="header-wrapper"><h3 id="constants"><bdi class="secno">5.3 </bdi>Constants</h3><a class="self-link" href="#constants" aria-label="Permalink for Section 5.3"></a></div><section id="rml-append"><div class="header-wrapper"><h4 id="x5-3-1-rml-append"><bdi class="secno">5.3.1 </bdi><code>rml:append</code></h4><a class="self-link" href="#rml-append" aria-label="Permalink for Section 5.3.1"></a></div>
<p><code>rml:append</code> is an instance of class <code>rml:Strategy</code>.
Used as the object of property <a href="rml-strategy"><code>rml:strategy</code></a>, it informs the processor that the sets of RDF terms generated by each term map of the gather map are to be appended within the collection or container. The order is that in which the term maps are declared in the gather map. Example:</p>
<p>For the input document:</p>
<pre class="ex-input" aria-busy="false"><code class="hljs">{ 
  "a": [ "1" , "2" , "3" ],
  "b": [ "4" , "5" ] 
}</code></pre>

<p>The following term map:</p>
<pre class="ex-mapping" aria-busy="false"><code class="hljs">rml:objectMap [
    rml:gather ( [ rml:reference "a.*" ] [ rml:reference "b.*" ]) ;
    rml:gatherAs rdf:List ;
    rml:strategy rml:append;   # this is the default strategy
] ;</code></pre>

<p>would generate a list by appending the terms produced by the two term maps in the gather map:</p>
<pre class="ex-output" aria-busy="false"><code class="hljs">("1" "2" "3" "4" "5" )</code></pre>


</section><section id="rml-cartesianproduct"><div class="header-wrapper"><h4 id="x5-3-2-rml-cartesianproduct"><bdi class="secno">5.3.2 </bdi><code>rml:cartesianProduct</code></h4><a class="self-link" href="#rml-cartesianproduct" aria-label="Permalink for Section 5.3.2"></a></div>
<p><code>rml:cartesianProduct</code> is an instance of class <code>rml:Strategy</code>.
Used as the object of property <a href="rml-strategy"><code>rml:strategy</code></a>, it informs the processor that the RDF terms generated by each term map of the gather map are to be grouped (in the constructed collection or container) by doing a cartesian product of these terms.
Therefore, this constructs as many collections or containers as the product of the number of terms from each term map. Example:</p>
<p>For the input document:</p>
<pre class="ex-input" aria-busy="false"><code class="hljs">{ 
  "a": [ "1" , "2" , "3" ],
  "b": [ "4" , "5" ] 
}</code></pre>

<p>The following term map:</p>
<pre class="ex-mapping" aria-busy="false"><code class="hljs">rml:objectMap [
    rml:gather ( [ rml:reference "a.*" ] [ rml:reference "b.*" ]) ;
    rml:gatherAs rdf:List ;
    rml:strategy rml:cartesianProduct;
] ;</code></pre>

<p>would generate 3*2 = 6 lists by grouping the terms produced by the two term maps in the gather map:</p>
<pre class="ex-output" aria-busy="false"><code class="hljs">("1" "4") ("1" "5") 
("2" "4") ("2" "5")
("3" "4") ("3" "5")</code></pre></section></section></section>

<section id="considerations-0"><div class="header-wrapper"><h2 id="considerations"><bdi class="secno">6. </bdi>Considerations</h2><a class="self-link" href="#considerations" aria-label="Permalink for Section 6."></a></div><section id="using-a-rml-gathermap-in-various-types-of-term-map"><div class="header-wrapper"><h3 id="x6-1-using-a-rml-gathermap-in-various-types-of-term-map"><bdi class="secno">6.1 </bdi>Using a <code>rml:GatherMap</code> in various types of term map</h3><a class="self-link" href="#using-a-rml-gathermap-in-various-types-of-term-map" aria-label="Permalink for Section 6.1"></a></div>
<p>Although most examples demonstrate the use of a gather map in the context of an object map, a gather map is a regular term map.
As such, it can be used in other types of term maps such as a subject or predicate map.</p>
<p>Term maps generate RDF terms (IRI, blank node, literal) to be used as the terms of RDF triples.
If such a term map generates a collection or container by means of a gather map, the term retained to form an RDF triple is the head node of the collection or container.
In the case of an RDF list, this is the node that is the subject of the first <code>rdf:first</code> predicate.</p>
<p>The <a href="#gatherinsubject">examples section</a> demonstrates how a gather map can be used within a subject map.</p>
</section><section id="named-collection-or-container-assigning-an-iri-or-blank-node-identifier-to-a-collection-and-container"><div class="header-wrapper"><h3 id="x6-2-named-collection-or-container-assigning-an-iri-or-blank-node-identifier-to-a-collection-and-container"><bdi class="secno">6.2 </bdi>Named collection or container: assigning an IRI or blank node identifier to a collection and container</h3><a class="self-link" href="#named-collection-or-container-assigning-an-iri-or-blank-node-identifier-to-a-collection-and-container" aria-label="Permalink for Section 6.2"></a></div>
<p>If a gather map does not contain any <code>rml:template</code>, <code>rml:constant</code> or <code>rml:reference</code> property, then the head node of each generated collection or container is a new blank node.</p>
<p>Conversely, if a gather map contains either a <code>rml:template</code>, <code>rml:constant</code> or <code>rml:reference</code> property, then the gather map yields <a href="#named"><strong>named collections or containers</strong></a> whose head node is identified as instructed by the <code>rml:template</code>, <code>rml:constant</code> or <code>rml:reference</code> property.</p>
<p>The following mapping:</p>
<pre class="ex-mapping" aria-busy="false"><code class="hljs">rml:predicateObjectMap [
  rml:predicate ex:with ;
  rml:objectMap [
      rml:template "seq{id}" ;
      rml:gather ( [ rml:reference "values.*" ; ] ) ;
      rml:gatherAs rdf:Seq ;
  ] ;
] ;</code></pre>

<p>will yield the following output:</p>
<pre class="ex-output" aria-busy="false"><code class="hljs">:a ex:with :seqa . :seqa rdf:_1 "1" ; rdf:_2 "2" , rdf:_3 "3" .
:b ex:with :seqb . :seqb rdf:_1 "4" ; rdf:_2 "5" , rdf:_3 "6" .
:c ex:with :seqc . :seqc rdf:_1 "7" ; rdf:_2 "8" , rdf:_3 "9"  .</code></pre>


</section><section id="generating-well-formed-named-collections-or-containers"><div class="header-wrapper"><h3 id="x6-3-generating-well-formed-named-collections-or-containers"><bdi class="secno">6.3 </bdi>Generating well-formed named collections or containers</h3><a class="self-link" href="#generating-well-formed-named-collections-or-containers" aria-label="Permalink for Section 6.3"></a></div>
<p>When generating a <a href="#named"><strong>named collection or container</strong></a>, it may happen that the same IRI or blank node identifier be generated several times, either across multiple <a href="#iterations">iterations</a> or because the gather map is <a href="#multivaluedtermmap">multi-valued</a> as exemplified with the <a href="#rml-cartesianproduct"><code>rml:cartesianProduct</code></a> strategy.</p>
<p>In this situation, to avoid generating <a href="#wellformedness">ill-formed collections or containers</a>, the processor <em class="rfc2119">MUST</em> concatenate (i.e. append) the new collection or container to the previous one. 
In other words, when a gather map creates a <a href="#named">named collection or container</a>, the processor must first check whether a named collection or container with the same head node IRI or blank node identifier already exists, and if so, it must append the terms to the existing one.</p>
<p>Below we exemplify two such situations.</p>
<section id="named-collections-or-containers-generated-across-multiple-iterations"><div class="header-wrapper"><h4 id="named-multi-iterations"><bdi class="secno">6.3.1 </bdi>Named collections or containers generated across multiple iterations</h4><a class="self-link" href="#named-multi-iterations" aria-label="Permalink for Section 6.3.1"></a></div><p>Here we reuse the <a href="#runningexample">running example</a> yet with a slight variation: there are two JSON objects with the value <code>"a"</code> for <code>"id"</code>.</p>
<pre class="ex-input" aria-busy="false"><code class="hljs">[ 
  { "id": "a",  "values": [ "1" , "2" , "3" ] },
  { "id": "b",  "values": [ "4" , "5" , "6" ] },
  { "id": "a",  "values": [ "7" , "8" , "9" ] } 
]</code></pre>

<p>Let's consider the following mapping:</p>
<pre class="ex-mapping" aria-busy="false"><code class="hljs">rml:predicateObjectMap [
  rml:predicate ex:with ;
  rml:objectMap [
      rml:gather ( [ rml:reference "values.*" ; ] ) ;
      rml:gatherAs rdf:List ;
  ] ;
] ;</code></pre>

<p>The gather map has no <code>rml:template</code>, <code>rml:constant</code> nor <code>rml:reference</code> property. The expected output consists of three lists, two related to <code>:a</code> and one to <code>:b</code>:</p>
<pre class="ex-output" aria-busy="false"><code class="hljs">:a ex:with ("1" "2" "3"), ("7" "8" "9")  .
:b ex:with ("4" "5" "6") .</code></pre>

<p>Now, when an <code>rml:template</code>, <code>rml:constant</code> or <code>rml:reference</code> is provided, 
the two collections related to id <code>"a"</code> cannot be generated separately since they would share the same head node IRI or bank node identifier, thus generating an <a href="#wellformedness">ill-formed collection</a>. Therefore, the processor must concatenate the two collections related to id <code>"a"</code>.
With the following predicate mapping:</p>
<pre class="ex-mapping" aria-busy="false"><code class="hljs">rml:predicateObjectMap [
  rml:predicate ex:with ;
  rml:objectMap [
      rml:template "list{id}" ;
      rml:gather ( [ rml:reference "values.*" ; ] ) ;
      rml:gatherAs rdf:List ;
  ] ;
] ;</code></pre>

<p>The processor must generate the following output:</p>
<pre class="ex-output" aria-busy="false"><code class="hljs">:a ex:with :lista . :lista rdf:first "1" ; rdf:rest ("2" "3" "7" "8" "9") .
:b ex:with :listb . :listb rdf:first "4" ; rdf:rest ("5" "6") .</code></pre>

<p>It is assumed that a processor will concatenate the collections or containers while respecting the order of the iterations as provided by the logical source.</p>
</section><section id="named-collections-or-containers-generated-by-a-multi-valued-gather-map"><div class="header-wrapper"><h4 id="named-multivalued"><bdi class="secno">6.3.2 </bdi>Named collections or containers generated by a multi-valued gather map</h4><a class="self-link" href="#named-multivalued" aria-label="Permalink for Section 6.3.2"></a></div><p>Let's consider the following input document:</p>
<pre class="ex-input" aria-busy="false"><code class="hljs">{ 
  "id": "myid",
  "a": [ "1" , "2" , "3" ],
  "b": [ "4" , "5" ] 
}</code></pre>

<p>and the following mapping:</p>
<pre class="ex-mapping" aria-busy="false"><code class="hljs">rml:subjectMap [ rml:template "{id}" ] ;

rml:predicateObjectMap [
  rml:predicate ex:with ;
  rml:objectMap [
    rml:gather ( [ rml:reference "a.*" ] [ rml:reference "b.*" ]) ;
    rml:gatherAs rdf:List ;
    rml:strategy rml:cartesianProduct ;
  ] ;
] ;</code></pre>

<p>The gather map has no <code>rml:template</code>, <code>rml:constant</code> nor <code>rml:reference</code> property. 
As already illustrated, the <a href="#rml-cartesianproduct"><code>rml:cartesianProduct</code></a> strategy will generate multiple collections, yielding the output:</p>
<pre class="ex-output" aria-busy="false"><code class="hljs">[] ex:with ("1" "4"), ("1" "5"), ("2" "4"), ("2" "5"), ("3" "4"), ("3" "5") .</code></pre>


<p>Now, when an <code>rml:template</code>, <code>rml:constant</code> or <code>rml:reference</code> is provided, to avoid generating <a href="#wellformedness">ill-formed lists</a> that would share the same head node IRI, the processor must concatenate the lists.</p>
<p>If we add an <code>rml:template</code> in the object map:</p>
<pre class="ex-mapping" aria-busy="false"><code class="hljs">rml:objectMap [
  rml:template "list{id}" ;
  rml:gather ( [ rml:reference "a.*" ] [ rml:reference "b.*" ]) ;
  rml:gatherAs rdf:List ;
  rml:strategy rml:cartesianProduct ;
] ;</code></pre>

<p>The processor must now generate the following output:</p>
<pre class="ex-output" aria-busy="false"><code class="hljs">:myid ex:with ("1" "4" "1" "5" "2" "4" "2" "5" "3" "4" "3" "5" ).</code></pre>



</section><section id="named-collections-or-containers-generated-across-multiple-iterations-and-with-a-multi-valued-term-map"><div class="header-wrapper"><h4 id="x6-3-3-named-collections-or-containers-generated-across-multiple-iterations-and-with-a-multi-valued-term-map"><bdi class="secno">6.3.3 </bdi>Named collections or containers generated across multiple iterations and with a multi-valued term map</h4><a class="self-link" href="#named-collections-or-containers-generated-across-multiple-iterations-and-with-a-multi-valued-term-map" aria-label="Permalink for Section 6.3.3"></a></div>
<p>An even more tricky situation combines the two previous sections, involving at the same time multiple iterations and multi-valued gather maps.</p>
<p>Let's consider the following document and mapping:</p>
<pre class="ex-input" aria-busy="false"><code class="hljs">[ 
  { "id": "a",  "values1": [ "1" ],       "values2": [ "a" , "b" ] },
  { "id": "b",  "values1": [ "3" , "4" ], "values2": [ "c" , "d" ] },
  { "id": "a",  "values1": [ "5" , "6" ], "values2": [ "e" ] } 
]</code></pre>

<pre class="ex-mapping" aria-busy="false"><code class="hljs">rml:logicalSource [
  ...
  rml:iterator "$.*" ;
];

rml:subjectMap [ rml:template "{id}" ] ;

rml:predicateObjectMap [
  rml:predicate ex:with ;
  rml:objectMap [
      rml:template "list{id}" ;
      rml:gather ( [ rml:reference "values1.*" ; ] [ rml:reference "values2.*" ; ] ) ;
      rml:gatherAs rdf:List ;
  ] ;
] ;</code></pre>

<p>For each document, the values of <code>values1</code> and <code>values2</code> are appended in the same list, as per the default <a href="#rml-append"><code>rml:append</code></a> strategy.
Furthermore, the lists generated for id <code>"a"</code> must be concatenated since they share the same head node IRI, as explained in the <a href="#named-multi-iterations">multiple iterations</a> case.
The expected output is:</p>
<pre class="ex-output" aria-busy="false"><code class="hljs">:a ex:with :lista .
:lista rdf:first "1" ; rdf:rest ("a" "b" "5" "6" "e") .
:b ex:with :listb .
:listb rdf:first "3" ; rdf:rest ("4" "c" "d") .</code></pre>

<p>Now let's change the default strategy to <code>rml:cartesianProduct</code>:</p>
<pre class="ex-mapping" aria-busy="false"><code class="hljs">rml:objectMap [
    rml:template "list{id}" ;
    rml:gather ( [ rml:reference "values1.*" ; ] [ rml:reference "values2.*" ; ] ) ;
    rml:gatherAs rdf:List ;
    rml:strategy rml:cartesianProduct ;
] ;</code></pre>

<p>Each <a href="#iterations">iteration</a> will now yield multiple lists by combining the values of <code>values1</code> and <code>values2</code>. </p>
<p>For the document with id <code>"b"</code>, there are <code>("3" "c") ("3" "d") ("4" "c") ("4" "d")</code>.
But since the template generates the same IRI for all of them, they must be concatenated into a single list: <code>("3" "c" "3" "d" "4" "c" "4" "d")</code>, as explained in the <a href="#named-multivalued">multi-valued gather map</a> case.</p>
<p>Similarly, for the documents with id <code>"a"</code>, the result is: <code>("1" "a" "1" "b")</code> and <code>("5" "e" "6" "e")</code>.
But again, these lists must be concatenated since they share the same head node IRI, as explained in the <a href="#named-multi-iterations">multiple iterations</a> case.</p>
<p>Therefore, the processor must now generate the following output:</p>
<pre class="ex-output" aria-busy="false"><code class="hljs">:a ex:with :lista .
:lista rdf:first "1" ; rdf:rest ("a" "1" "b" "5" "e" "6" "e") .
:b ex:with :listb .
:listb rdf:first "3" ; rdf:rest ("c" "3" "d" "4" "c" "4" "d") .</code></pre></section></section></section>

<section id="examples-informative"><div class="header-wrapper"><h2 id="examples"><bdi class="secno">7. </bdi>Examples (Informative)</h2><a class="self-link" href="#examples" aria-label="Permalink for Section 7."></a></div><p>In this section, we present additional examples and describe the expected output.</p>
<section id="dealing-with-empty-collections-and-containers"><div class="header-wrapper"><h3 id="x7-1-dealing-with-empty-collections-and-containers"><bdi class="secno">7.1 </bdi>Dealing with empty collections and containers</h3><a class="self-link" href="#dealing-with-empty-collections-and-containers" aria-label="Permalink for Section 7.1"></a></div>
<p>By default, <a href="#rml-allowemptylistandcontainer"><code>rml:allowEmptyListAndContainer</code></a> is false. 
Thus, processing the following JSON document with the predicate object map provided in the <a href="#runningexample">running example</a> would not yield any result for the document with <code>"id": "d"</code>.</p>
<pre class="ex-input" aria-busy="false"><code class="hljs">[ 
  { "id": "a",  "values": [ "1" , "2" , "3" ] },
  { "id": "b",  "values": [ "4" , "5" , "6" ] },
  { "id": "c",  "values": [ "7" , "8" , "9" ] },
  { "id": "d",  "values": [] } 
]</code></pre>

<p>However, when we override the value for this property and set it to true:</p>
<pre class="ex-mapping" aria-busy="false"><code class="hljs">rml:predicateObjectMap [
  rml:predicate ex:with ;
  rml:objectMap [
      rml:allowEmptyListAndContainer true ;
      rml:gather ( [ rml:reference "values.*" ; ] ) ;
      rml:gatherAs rdf:List ;
  ] ;
] ;</code></pre>

<p>the predicate object map will generate:</p>
<pre class="ex-output" aria-busy="false"><code class="hljs">:a ex:with ("1" "2" "3") .
:b ex:with ("4" "5" "6") .
:c ex:with ("7" "8" "9") .
:d ex:with () .</code></pre>

<p>There is one special case when dealing with empty <em>collections</em>. Since <code>rdf:nil</code> is reserved for the empty list, an RML processor <em class="rfc2119">MUST</em> replace each IRI or blank node that is an empty list with <code>rdf:nil</code>. 
In other words, when the following predicate object map is used:</p>
<pre class="ex-mapping" aria-busy="false"><code class="hljs">rml:predicateObjectMap [
  rml:predicate ex:with ;
  rml:objectMap [
      rml:template "list{id}" ;
      rml:allowEmptyListAndContainer true ;
      rml:gather ( [ rml:reference "values.*" ; ] ) ;
      rml:gatherAs rdf:List ;
  ] ;
] ;</code></pre>

<p>then the document with <code>"id": "d"</code> entails an empty list, that is a list whose head node is <code>rdf:nil</code> and therefore has no IRI.
We expect the following output where</p>
<pre class="ex-output" aria-busy="false"><code class="hljs">:a ex:with :lista .
:lista rdf:first "1" ; rdf:rest ("2" "3") .
:b ex:with :listb .
:listb rdf:first "4" ; rdf:rest ("5" "6") .
:c ex:with :listc .
:listc rdf:first "7" ; rdf:rest ("8" "9") .
:d ex:with () .</code></pre>


</section><section id="relational-data-example"><div class="header-wrapper"><h3 id="relationalexample"><bdi class="secno">7.2 </bdi>Relational data example</h3><a class="self-link" href="#relationalexample" aria-label="Permalink for Section 7.2"></a></div><p>In this section, we use the following relational database and document for our example.</p>
<p>Table <code>BOOK</code>:</p>
<table>
<thead>
<tr>
<th>ID</th>
<th>TITLE</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>Frankenstein</td>
</tr>
<tr>
<td>2</td>
<td>The Long Earth</td>
</tr>
</tbody></table>
<p>Table <code>AUTHOR</code>:</p>
<table>
<thead>
<tr>
<th>ID</th>
<th>TITLE</th>
<th>FNAME</th>
<th>LNAME</th>
<th>BOOKID</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td></td>
<td>Mary</td>
<td>Shelley</td>
<td>1</td>
</tr>
<tr>
<td>2</td>
<td>Sir</td>
<td>Terry</td>
<td>Pratchett</td>
<td>2</td>
</tr>
<tr>
<td>3</td>
<td></td>
<td>Stephen</td>
<td>Baxter</td>
<td>2</td>
</tr>
<tr>
<td>4</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>The following mapping will relate instances of authors to names. The names of authors are, for the sake of the example, represented as bags containing a title, first name, and lastname.</p>
<pre class="ex-mapping" aria-busy="false"><code class="hljs">&lt;#AuthorTM&gt;
    rml:logicalTable [ rml:tableName "AUTHOR" ; ] ;
    rml:subjectMap [ rml:template "/person{ID}" ; ] ;
    rml:predicateObjectMap [
        rml:predicate ex:name ;
        rml:objectMap [
            rml:reference "ID" ; rml:termType rml:BlankNode ;
            rml:gather ( 
                [ rml:reference "TITLE" ]  [ rml:reference "FNAME" ]  [ rml:reference "LNAME" ] 
            ) ;
            rml:gatherAs rdf:Bag ;
        ] ;
    ] ;
.</code></pre>

<p>In this example we generate, for each row in table <code>AUTHOR</code>, an blank node of type <code>rdf:Bag</code>. Each such bag "gathers" values from different term maps. The execution of this mapping will produce the following result:</p>
<pre class="ex-output" aria-busy="false"><code class="hljs">:person1 ex:name [ a rdf:Bag; rdf:_1 "Mary"; rdf:_2 "Shelley" ] . 
:person2 ex:name [ a rdf:Bag; rdf:_1 "Sir"; rdf:_2 "Terry"; rdf:_3 "Pratchett" ] . 
:person3 ex:name [ a rdf:Bag; rdf:_1 "Stephen"; rdf:_2 "Baxter" ] .</code></pre>

<p>While not shown in this example, different term maps allow to collect terms of different types: resources, literals, typed or language-tagged literals, etc. The fourth record in the table did not generate a bag, since each term map in the gather map did not yield a value. 
By default, empty lists and containers are withheld. One does have the possibility to keep those with <a href="#rml-allowemptylistandcontainer"><code>rml:allowEmptyListAndContainer</code></a>`.</p>
</section><section id="using-referencing-object-map"><div class="header-wrapper"><h3 id="x7-3-using-referencing-object-map"><bdi class="secno">7.3 </bdi>Using referencing object map</h3><a class="self-link" href="#using-referencing-object-map" aria-label="Permalink for Section 7.3"></a></div>
<p>Continuing with the <a href="#relationalexample">relational data example</a>, here we relate books to authors with a <code>rml:parentTriplesMap</code>. The authors of a book are represented as a list.</p>
<pre class="ex-mapping" aria-busy="false"><code class="hljs">&lt;#BookTM&gt;
    rml:logicalTable [ rml:tableName "BOOK" ; ] ;
    rml:subjectMap [ rml:template "/book{ID}" ; ] ;
    rml:predicateObjectMap [
        rml:predicate ex:writtenBy ;
        rml:objectMap [
            rml:reference "ID" ; rml:termType rml:BlankNode ;
            rml:gather ( 
                [ 
                    rml:parentTriplesMap &lt;#AuthorTM&gt;;
                    rml:joinCondition [ rml:child "ID" ; rml:parent "BOOKID" ; ] ;
                ] 
            ) ;
            rml:gatherAs rdf:List;
        ] ;
    ] ;
.</code></pre>

<p>Intuitively, we will join each record (or iteration) with data from the parent triples map. The join may yield one or more results, which are then gathered into a list. The execution of this mapping will produce the following RDF:</p>
<pre class="ex-output" aria-busy="false"><code class="hljs">:book1 ex:writtenby ( :person1 ) . 
:book2 ex:writtenby ( :person2 :person3 ) .</code></pre>

<p>In RML, it is assumed that each term map is multi-valued. That this, each term map may return one or more values. The default behavior is to append the values in the order of the term maps appearing in the gather map.</p>
</section><section id="using-a-gather-map-in-a-subject-map"><div class="header-wrapper"><h3 id="gatherinsubject"><bdi class="secno">7.4 </bdi>Using a gather map in a subject map</h3><a class="self-link" href="#gatherinsubject" aria-label="Permalink for Section 7.4"></a></div><p>Here we exemplify the use of a term map in a subject map. Continuing with the JSON file from the <a href="#runningexample">running example</a>, the following mapping generates an RDF sequence whose head node is used to state provenance information on that sequence:</p>
<pre class="ex-mapping" aria-busy="false"><code class="hljs">&lt;#TM&gt; a rml:TriplesMap;
  rml:logicalSource [
    rml:source [ 
        a rml:RelativePathSource;
        rml:root rml:MappingDirectory;
        rml:path "data.json"
    ] ;
    rml:iterator "$.*" ;
  ];

  rml:subjectMap [
    rml:template "seq{id}" ;
    rml:gather ( [ rml:reference "values.*" ; ] ) ;
    rml:gatherAs rdf:Seq ;  
  ] ;
  
  rml:predicateObjectMap [
    rml:predicate prov:wasDerivedFrom ;
    rml:object &lt;data.json&gt; ;
  ] .</code></pre>

<p>The expected result is:</p>
<pre class="ex-output" aria-busy="false"><code class="hljs">:seqa rdf:_1 "1" ; rdf:_2 "2" ; rdf:_3 "3" .
:seqa prov:wasDerivedFrom &lt;data.json&gt; .

:seqb rdf:_1 "4" ; rdf:_2 "5" ; rdf:_3 "6" .
:seqb prov:wasDerivedFrom &lt;data.json&gt; .

:seqc rdf:_1 "7" ; rdf:_2 "8" ; rdf:_3 "9" .
:seqc prov:wasDerivedFrom &lt;data.json&gt; .</code></pre></section></section>



<section id="references" class="appendix"><div class="header-wrapper"><h2 id="a-references"><bdi class="secno">A. </bdi>References</h2><a class="self-link" href="#references" aria-label="Permalink for Appendix A."></a></div><section id="normative-references"><div class="header-wrapper"><h3 id="a-1-normative-references"><bdi class="secno">A.1 </bdi>Normative references</h3><a class="self-link" href="#normative-references" aria-label="Permalink for Appendix A.1"></a></div>
    
    <dl class="bibliography"><dt id="bib-r2rml">[R2RML]</dt><dd>
      <a href="https://www.w3.org/TR/r2rml/"><cite>R2RML: RDB to RDF Mapping Language</cite></a>.  W3C. 27 September 2012. W3C Recommendation. URL: <a href="https://www.w3.org/TR/r2rml/">https://www.w3.org/TR/r2rml/</a>
    </dd><dt id="bib-rfc2119">[RFC2119]</dt><dd>
      <a href="https://www.rfc-editor.org/rfc/rfc2119"><cite>Key words for use in RFCs to Indicate Requirement Levels</cite></a>. S. Bradner.  IETF. March 1997. Best Current Practice. URL: <a href="https://www.rfc-editor.org/rfc/rfc2119">https://www.rfc-editor.org/rfc/rfc2119</a>
    </dd><dt id="bib-rfc8174">[RFC8174]</dt><dd>
      <a href="https://www.rfc-editor.org/rfc/rfc8174"><cite>Ambiguity of Uppercase vs Lowercase in RFC 2119 Key Words</cite></a>. B. Leiba.  IETF. May 2017. Best Current Practice. URL: <a href="https://www.rfc-editor.org/rfc/rfc8174">https://www.rfc-editor.org/rfc/rfc8174</a>
    </dd><dt id="bib-rml">[RML]</dt><dd>
      <a href="https://rml.io/specs/rml/"><cite>RDF Mapping Language</cite></a>.  https://rml.io. 06 October 2020. Unofficial draft. URL: <a href="https://rml.io/specs/rml/">https://rml.io/specs/rml/</a>
    </dd><dt id="bib-turtle">[Turtle]</dt><dd>
      <a href="https://www.w3.org/TR/turtle/"><cite>RDF 1.1 Turtle</cite></a>.  W3C. 25 February 2014. W3C Recommendation. URL: <a href="https://www.w3.org/TR/turtle/">https://www.w3.org/TR/turtle/</a>
    </dd></dl>
  </section><section id="informative-references"><div class="header-wrapper"><h3 id="a-2-informative-references"><bdi class="secno">A.2 </bdi>Informative references</h3><a class="self-link" href="#informative-references" aria-label="Permalink for Appendix A.2"></a></div>
    
    <dl class="bibliography"><dt id="bib-rdf11-concepts">[RDF11-Concepts]</dt><dd>
      <a href="https://www.w3.org/TR/rdf11-concepts/"><cite>RDF 1.1 Concepts and Abstract Syntax</cite></a>.  W3C. 25 February 2014. W3C Recommendation. URL: <a href="https://www.w3.org/TR/rdf11-concepts/">https://www.w3.org/TR/rdf11-concepts/</a>
    </dd></dl>
  </section></section><p role="navigation" id="back-to-top">
    <a href="#title"><abbr title="Back to Top">↑</abbr></a>
  </p><script id="respec-dfn-panel">(() => {
// @ts-check
if (document.respec) {
  document.respec.ready.then(setupPanel);
} else {
  setupPanel();
}

function setupPanel() {
  const listener = panelListener();
  document.body.addEventListener("keydown", listener);
  document.body.addEventListener("click", listener);
}

function panelListener() {
  /** @type {HTMLElement} */
  let panel = null;
  return event => {
    const { target, type } = event;

    if (!(target instanceof HTMLElement)) return;

    // For keys, we only care about Enter key to activate the panel
    // otherwise it's activated via a click.
    if (type === "keydown" && event.key !== "Enter") return;

    const action = deriveAction(event);

    switch (action) {
      case "show": {
        hidePanel(panel);
        /** @type {HTMLElement} */
        const dfn = target.closest("dfn, .index-term");
        panel = document.getElementById(`dfn-panel-for-${dfn.id}`);
        const coords = deriveCoordinates(event);
        displayPanel(dfn, panel, coords);
        break;
      }
      case "dock": {
        panel.style.left = null;
        panel.style.top = null;
        panel.classList.add("docked");
        break;
      }
      case "hide": {
        hidePanel(panel);
        panel = null;
        break;
      }
    }
  };
}

/**
 * @param {MouseEvent|KeyboardEvent} event
 */
function deriveCoordinates(event) {
  const target = /** @type HTMLElement */ (event.target);

  // We prevent synthetic AT clicks from putting
  // the dialog in a weird place. The AT events sometimes
  // lack coordinates, so they have clientX/Y = 0
  const rect = target.getBoundingClientRect();
  if (
    event instanceof MouseEvent &&
    event.clientX >= rect.left &&
    event.clientY >= rect.top
  ) {
    // The event probably happened inside the bounding rect...
    return { x: event.clientX, y: event.clientY };
  }

  // Offset to the middle of the element
  const x = rect.x + rect.width / 2;
  // Placed at the bottom of the element
  const y = rect.y + rect.height;
  return { x, y };
}

/**
 * @param {Event} event
 */
function deriveAction(event) {
  const target = /** @type {HTMLElement} */ (event.target);
  const hitALink = !!target.closest("a");
  if (target.closest("dfn:not([data-cite]), .index-term")) {
    return hitALink ? "none" : "show";
  }
  if (target.closest(".dfn-panel")) {
    if (hitALink) {
      return target.classList.contains("self-link") ? "hide" : "dock";
    }
    const panel = target.closest(".dfn-panel");
    return panel.classList.contains("docked") ? "hide" : "none";
  }
  if (document.querySelector(".dfn-panel:not([hidden])")) {
    return "hide";
  }
  return "none";
}

/**
 * @param {HTMLElement} dfn
 * @param {HTMLElement} panel
 * @param {{ x: number, y: number }} clickPosition
 */
function displayPanel(dfn, panel, { x, y }) {
  panel.hidden = false;
  // distance (px) between edge of panel and the pointing triangle (caret)
  const MARGIN = 20;

  const dfnRects = dfn.getClientRects();
  // Find the `top` offset when the `dfn` can be spread across multiple lines
  let closestTop = 0;
  let minDiff = Infinity;
  for (const rect of dfnRects) {
    const { top, bottom } = rect;
    const diffFromClickY = Math.abs((top + bottom) / 2 - y);
    if (diffFromClickY < minDiff) {
      minDiff = diffFromClickY;
      closestTop = top;
    }
  }

  const top = window.scrollY + closestTop + dfnRects[0].height;
  const left = x - MARGIN;
  panel.style.left = `${left}px`;
  panel.style.top = `${top}px`;

  // Find if the panel is flowing out of the window
  const panelRect = panel.getBoundingClientRect();
  const SCREEN_WIDTH = Math.min(window.innerWidth, window.screen.width);
  if (panelRect.right > SCREEN_WIDTH) {
    const newLeft = Math.max(MARGIN, x + MARGIN - panelRect.width);
    const newCaretOffset = left - newLeft;
    panel.style.left = `${newLeft}px`;
    /** @type {HTMLElement} */
    const caret = panel.querySelector(".caret");
    caret.style.left = `${newCaretOffset}px`;
  }

  // As it's a dialog, we trap focus.
  // TODO: when <dialog> becomes a implemented, we should really
  // use that.
  trapFocus(panel, dfn);
}

/**
 * @param {HTMLElement} panel
 * @param {HTMLElement} dfn
 * @returns
 */
function trapFocus(panel, dfn) {
  /** @type NodeListOf<HTMLAnchorElement> elements */
  const anchors = panel.querySelectorAll("a[href]");
  // No need to trap focus
  if (!anchors.length) return;

  // Move focus to first anchor element
  const first = anchors.item(0);
  first.focus();

  const trapListener = createTrapListener(anchors, panel, dfn);
  panel.addEventListener("keydown", trapListener);

  // Hiding the panel releases the trap
  const mo = new MutationObserver(records => {
    const [record] = records;
    const target = /** @type HTMLElement */ (record.target);
    if (target.hidden) {
      panel.removeEventListener("keydown", trapListener);
      mo.disconnect();
    }
  });
  mo.observe(panel, { attributes: true, attributeFilter: ["hidden"] });
}

/**
 *
 * @param {NodeListOf<HTMLAnchorElement>} anchors
 * @param {HTMLElement} panel
 * @param {HTMLElement} dfn
 * @returns
 */
function createTrapListener(anchors, panel, dfn) {
  const lastIndex = anchors.length - 1;
  let currentIndex = 0;
  return event => {
    switch (event.key) {
      // Hitting "Tab" traps us in a nice loop around elements.
      case "Tab": {
        event.preventDefault();
        currentIndex += event.shiftKey ? -1 : +1;
        if (currentIndex < 0) {
          currentIndex = lastIndex;
        } else if (currentIndex > lastIndex) {
          currentIndex = 0;
        }
        anchors.item(currentIndex).focus();
        break;
      }

      // Hitting "Enter" on an anchor releases the trap.
      case "Enter":
        hidePanel(panel);
        break;

      // Hitting "Escape" returns focus to dfn.
      case "Escape":
        hidePanel(panel);
        dfn.focus();
        return;
    }
  };
}

/** @param {HTMLElement} panel */
function hidePanel(panel) {
  if (!panel) return;
  panel.hidden = true;
  panel.classList.remove("docked");
}
})()</script><script src="https://www.w3.org/scripts/TR/2021/fixup.js"></script></body><grammarly-desktop-integration data-grammarly-shadow-root="true"></grammarly-desktop-integration></html>